// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"go.6river.tech/mmmbbb/ent/delivery"
	"go.6river.tech/mmmbbb/ent/message"
	"go.6river.tech/mmmbbb/ent/predicate"
	"go.6river.tech/mmmbbb/ent/snapshot"
	"go.6river.tech/mmmbbb/ent/subscription"
	"go.6river.tech/mmmbbb/ent/topic"
	"go.6river.tech/mmmbbb/internal/sqltypes"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDelivery     = "Delivery"
	TypeMessage      = "Message"
	TypeSnapshot     = "Snapshot"
	TypeSubscription = "Subscription"
	TypeTopic        = "Topic"
)

// DeliveryMutation represents an operation that mutates the Delivery nodes in the graph.
type DeliveryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	publishedAt         *time.Time
	attemptAt           *time.Time
	lastAttemptedAt     *time.Time
	attempts            *int
	addattempts         *int
	completedAt         *time.Time
	expiresAt           *time.Time
	clearedFields       map[string]struct{}
	message             *uuid.UUID
	clearedmessage      bool
	subscription        *uuid.UUID
	clearedsubscription bool
	notBefore           *uuid.UUID
	clearednotBefore    bool
	nextReady           map[uuid.UUID]struct{}
	removednextReady    map[uuid.UUID]struct{}
	clearednextReady    bool
	done                bool
	oldValue            func(context.Context) (*Delivery, error)
	predicates          []predicate.Delivery
}

var _ ent.Mutation = (*DeliveryMutation)(nil)

// deliveryOption allows management of the mutation configuration using functional options.
type deliveryOption func(*DeliveryMutation)

// newDeliveryMutation creates new mutation for the Delivery entity.
func newDeliveryMutation(c config, op Op, opts ...deliveryOption) *DeliveryMutation {
	m := &DeliveryMutation{
		config:        c,
		op:            op,
		typ:           TypeDelivery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryID sets the ID field of the mutation.
func withDeliveryID(id uuid.UUID) deliveryOption {
	return func(m *DeliveryMutation) {
		var (
			err   error
			once  sync.Once
			value *Delivery
		)
		m.oldValue = func(ctx context.Context) (*Delivery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Delivery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelivery sets the old Delivery of the mutation.
func withDelivery(node *Delivery) deliveryOption {
	return func(m *DeliveryMutation) {
		m.oldValue = func(context.Context) (*Delivery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Delivery entities.
func (m *DeliveryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Delivery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageID sets the "messageID" field.
func (m *DeliveryMutation) SetMessageID(u uuid.UUID) {
	m.message = &u
}

// MessageID returns the value of the "messageID" field in the mutation.
func (m *DeliveryMutation) MessageID() (r uuid.UUID, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "messageID" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldMessageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "messageID" field.
func (m *DeliveryMutation) ResetMessageID() {
	m.message = nil
}

// SetSubscriptionID sets the "subscriptionID" field.
func (m *DeliveryMutation) SetSubscriptionID(u uuid.UUID) {
	m.subscription = &u
}

// SubscriptionID returns the value of the "subscriptionID" field in the mutation.
func (m *DeliveryMutation) SubscriptionID() (r uuid.UUID, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscriptionID" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldSubscriptionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscriptionID" field.
func (m *DeliveryMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// SetPublishedAt sets the "publishedAt" field.
func (m *DeliveryMutation) SetPublishedAt(t time.Time) {
	m.publishedAt = &t
}

// PublishedAt returns the value of the "publishedAt" field in the mutation.
func (m *DeliveryMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.publishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "publishedAt" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ResetPublishedAt resets all changes to the "publishedAt" field.
func (m *DeliveryMutation) ResetPublishedAt() {
	m.publishedAt = nil
}

// SetAttemptAt sets the "attemptAt" field.
func (m *DeliveryMutation) SetAttemptAt(t time.Time) {
	m.attemptAt = &t
}

// AttemptAt returns the value of the "attemptAt" field in the mutation.
func (m *DeliveryMutation) AttemptAt() (r time.Time, exists bool) {
	v := m.attemptAt
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptAt returns the old "attemptAt" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldAttemptAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptAt: %w", err)
	}
	return oldValue.AttemptAt, nil
}

// ResetAttemptAt resets all changes to the "attemptAt" field.
func (m *DeliveryMutation) ResetAttemptAt() {
	m.attemptAt = nil
}

// SetLastAttemptedAt sets the "lastAttemptedAt" field.
func (m *DeliveryMutation) SetLastAttemptedAt(t time.Time) {
	m.lastAttemptedAt = &t
}

// LastAttemptedAt returns the value of the "lastAttemptedAt" field in the mutation.
func (m *DeliveryMutation) LastAttemptedAt() (r time.Time, exists bool) {
	v := m.lastAttemptedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAttemptedAt returns the old "lastAttemptedAt" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldLastAttemptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAttemptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAttemptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAttemptedAt: %w", err)
	}
	return oldValue.LastAttemptedAt, nil
}

// ClearLastAttemptedAt clears the value of the "lastAttemptedAt" field.
func (m *DeliveryMutation) ClearLastAttemptedAt() {
	m.lastAttemptedAt = nil
	m.clearedFields[delivery.FieldLastAttemptedAt] = struct{}{}
}

// LastAttemptedAtCleared returns if the "lastAttemptedAt" field was cleared in this mutation.
func (m *DeliveryMutation) LastAttemptedAtCleared() bool {
	_, ok := m.clearedFields[delivery.FieldLastAttemptedAt]
	return ok
}

// ResetLastAttemptedAt resets all changes to the "lastAttemptedAt" field.
func (m *DeliveryMutation) ResetLastAttemptedAt() {
	m.lastAttemptedAt = nil
	delete(m.clearedFields, delivery.FieldLastAttemptedAt)
}

// SetAttempts sets the "attempts" field.
func (m *DeliveryMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *DeliveryMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *DeliveryMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *DeliveryMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *DeliveryMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetCompletedAt sets the "completedAt" field.
func (m *DeliveryMutation) SetCompletedAt(t time.Time) {
	m.completedAt = &t
}

// CompletedAt returns the value of the "completedAt" field in the mutation.
func (m *DeliveryMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completedAt" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completedAt" field.
func (m *DeliveryMutation) ClearCompletedAt() {
	m.completedAt = nil
	m.clearedFields[delivery.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completedAt" field was cleared in this mutation.
func (m *DeliveryMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[delivery.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completedAt" field.
func (m *DeliveryMutation) ResetCompletedAt() {
	m.completedAt = nil
	delete(m.clearedFields, delivery.FieldCompletedAt)
}

// SetExpiresAt sets the "expiresAt" field.
func (m *DeliveryMutation) SetExpiresAt(t time.Time) {
	m.expiresAt = &t
}

// ExpiresAt returns the value of the "expiresAt" field in the mutation.
func (m *DeliveryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expiresAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expiresAt" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expiresAt" field.
func (m *DeliveryMutation) ResetExpiresAt() {
	m.expiresAt = nil
}

// SetNotBeforeID sets the "notBeforeID" field.
func (m *DeliveryMutation) SetNotBeforeID(u uuid.UUID) {
	m.notBefore = &u
}

// NotBeforeID returns the value of the "notBeforeID" field in the mutation.
func (m *DeliveryMutation) NotBeforeID() (r uuid.UUID, exists bool) {
	v := m.notBefore
	if v == nil {
		return
	}
	return *v, true
}

// OldNotBeforeID returns the old "notBeforeID" field's value of the Delivery entity.
// If the Delivery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryMutation) OldNotBeforeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotBeforeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotBeforeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotBeforeID: %w", err)
	}
	return oldValue.NotBeforeID, nil
}

// ClearNotBeforeID clears the value of the "notBeforeID" field.
func (m *DeliveryMutation) ClearNotBeforeID() {
	m.notBefore = nil
	m.clearedFields[delivery.FieldNotBeforeID] = struct{}{}
}

// NotBeforeIDCleared returns if the "notBeforeID" field was cleared in this mutation.
func (m *DeliveryMutation) NotBeforeIDCleared() bool {
	_, ok := m.clearedFields[delivery.FieldNotBeforeID]
	return ok
}

// ResetNotBeforeID resets all changes to the "notBeforeID" field.
func (m *DeliveryMutation) ResetNotBeforeID() {
	m.notBefore = nil
	delete(m.clearedFields, delivery.FieldNotBeforeID)
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *DeliveryMutation) ClearMessage() {
	m.clearedmessage = true
	m.clearedFields[delivery.FieldMessageID] = struct{}{}
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *DeliveryMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *DeliveryMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *DeliveryMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *DeliveryMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[delivery.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *DeliveryMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryMutation) SubscriptionIDs() (ids []uuid.UUID) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *DeliveryMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// ClearNotBefore clears the "notBefore" edge to the Delivery entity.
func (m *DeliveryMutation) ClearNotBefore() {
	m.clearednotBefore = true
	m.clearedFields[delivery.FieldNotBeforeID] = struct{}{}
}

// NotBeforeCleared reports if the "notBefore" edge to the Delivery entity was cleared.
func (m *DeliveryMutation) NotBeforeCleared() bool {
	return m.NotBeforeIDCleared() || m.clearednotBefore
}

// NotBeforeIDs returns the "notBefore" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotBeforeID instead. It exists only for internal usage by the builders.
func (m *DeliveryMutation) NotBeforeIDs() (ids []uuid.UUID) {
	if id := m.notBefore; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotBefore resets all changes to the "notBefore" edge.
func (m *DeliveryMutation) ResetNotBefore() {
	m.notBefore = nil
	m.clearednotBefore = false
}

// AddNextReadyIDs adds the "nextReady" edge to the Delivery entity by ids.
func (m *DeliveryMutation) AddNextReadyIDs(ids ...uuid.UUID) {
	if m.nextReady == nil {
		m.nextReady = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nextReady[ids[i]] = struct{}{}
	}
}

// ClearNextReady clears the "nextReady" edge to the Delivery entity.
func (m *DeliveryMutation) ClearNextReady() {
	m.clearednextReady = true
}

// NextReadyCleared reports if the "nextReady" edge to the Delivery entity was cleared.
func (m *DeliveryMutation) NextReadyCleared() bool {
	return m.clearednextReady
}

// RemoveNextReadyIDs removes the "nextReady" edge to the Delivery entity by IDs.
func (m *DeliveryMutation) RemoveNextReadyIDs(ids ...uuid.UUID) {
	if m.removednextReady == nil {
		m.removednextReady = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nextReady, ids[i])
		m.removednextReady[ids[i]] = struct{}{}
	}
}

// RemovedNextReady returns the removed IDs of the "nextReady" edge to the Delivery entity.
func (m *DeliveryMutation) RemovedNextReadyIDs() (ids []uuid.UUID) {
	for id := range m.removednextReady {
		ids = append(ids, id)
	}
	return
}

// NextReadyIDs returns the "nextReady" edge IDs in the mutation.
func (m *DeliveryMutation) NextReadyIDs() (ids []uuid.UUID) {
	for id := range m.nextReady {
		ids = append(ids, id)
	}
	return
}

// ResetNextReady resets all changes to the "nextReady" edge.
func (m *DeliveryMutation) ResetNextReady() {
	m.nextReady = nil
	m.clearednextReady = false
	m.removednextReady = nil
}

// Where appends a list predicates to the DeliveryMutation builder.
func (m *DeliveryMutation) Where(ps ...predicate.Delivery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Delivery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Delivery).
func (m *DeliveryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.message != nil {
		fields = append(fields, delivery.FieldMessageID)
	}
	if m.subscription != nil {
		fields = append(fields, delivery.FieldSubscriptionID)
	}
	if m.publishedAt != nil {
		fields = append(fields, delivery.FieldPublishedAt)
	}
	if m.attemptAt != nil {
		fields = append(fields, delivery.FieldAttemptAt)
	}
	if m.lastAttemptedAt != nil {
		fields = append(fields, delivery.FieldLastAttemptedAt)
	}
	if m.attempts != nil {
		fields = append(fields, delivery.FieldAttempts)
	}
	if m.completedAt != nil {
		fields = append(fields, delivery.FieldCompletedAt)
	}
	if m.expiresAt != nil {
		fields = append(fields, delivery.FieldExpiresAt)
	}
	if m.notBefore != nil {
		fields = append(fields, delivery.FieldNotBeforeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delivery.FieldMessageID:
		return m.MessageID()
	case delivery.FieldSubscriptionID:
		return m.SubscriptionID()
	case delivery.FieldPublishedAt:
		return m.PublishedAt()
	case delivery.FieldAttemptAt:
		return m.AttemptAt()
	case delivery.FieldLastAttemptedAt:
		return m.LastAttemptedAt()
	case delivery.FieldAttempts:
		return m.Attempts()
	case delivery.FieldCompletedAt:
		return m.CompletedAt()
	case delivery.FieldExpiresAt:
		return m.ExpiresAt()
	case delivery.FieldNotBeforeID:
		return m.NotBeforeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delivery.FieldMessageID:
		return m.OldMessageID(ctx)
	case delivery.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case delivery.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case delivery.FieldAttemptAt:
		return m.OldAttemptAt(ctx)
	case delivery.FieldLastAttemptedAt:
		return m.OldLastAttemptedAt(ctx)
	case delivery.FieldAttempts:
		return m.OldAttempts(ctx)
	case delivery.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case delivery.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case delivery.FieldNotBeforeID:
		return m.OldNotBeforeID(ctx)
	}
	return nil, fmt.Errorf("unknown Delivery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delivery.FieldMessageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case delivery.FieldSubscriptionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case delivery.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case delivery.FieldAttemptAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptAt(v)
		return nil
	case delivery.FieldLastAttemptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAttemptedAt(v)
		return nil
	case delivery.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case delivery.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case delivery.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case delivery.FieldNotBeforeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotBeforeID(v)
		return nil
	}
	return fmt.Errorf("unknown Delivery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, delivery.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case delivery.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case delivery.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown Delivery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delivery.FieldLastAttemptedAt) {
		fields = append(fields, delivery.FieldLastAttemptedAt)
	}
	if m.FieldCleared(delivery.FieldCompletedAt) {
		fields = append(fields, delivery.FieldCompletedAt)
	}
	if m.FieldCleared(delivery.FieldNotBeforeID) {
		fields = append(fields, delivery.FieldNotBeforeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryMutation) ClearField(name string) error {
	switch name {
	case delivery.FieldLastAttemptedAt:
		m.ClearLastAttemptedAt()
		return nil
	case delivery.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case delivery.FieldNotBeforeID:
		m.ClearNotBeforeID()
		return nil
	}
	return fmt.Errorf("unknown Delivery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryMutation) ResetField(name string) error {
	switch name {
	case delivery.FieldMessageID:
		m.ResetMessageID()
		return nil
	case delivery.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case delivery.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case delivery.FieldAttemptAt:
		m.ResetAttemptAt()
		return nil
	case delivery.FieldLastAttemptedAt:
		m.ResetLastAttemptedAt()
		return nil
	case delivery.FieldAttempts:
		m.ResetAttempts()
		return nil
	case delivery.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case delivery.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case delivery.FieldNotBeforeID:
		m.ResetNotBeforeID()
		return nil
	}
	return fmt.Errorf("unknown Delivery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.message != nil {
		edges = append(edges, delivery.EdgeMessage)
	}
	if m.subscription != nil {
		edges = append(edges, delivery.EdgeSubscription)
	}
	if m.notBefore != nil {
		edges = append(edges, delivery.EdgeNotBefore)
	}
	if m.nextReady != nil {
		edges = append(edges, delivery.EdgeNextReady)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case delivery.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case delivery.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case delivery.EdgeNotBefore:
		if id := m.notBefore; id != nil {
			return []ent.Value{*id}
		}
	case delivery.EdgeNextReady:
		ids := make([]ent.Value, 0, len(m.nextReady))
		for id := range m.nextReady {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removednextReady != nil {
		edges = append(edges, delivery.EdgeNextReady)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case delivery.EdgeNextReady:
		ids := make([]ent.Value, 0, len(m.removednextReady))
		for id := range m.removednextReady {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmessage {
		edges = append(edges, delivery.EdgeMessage)
	}
	if m.clearedsubscription {
		edges = append(edges, delivery.EdgeSubscription)
	}
	if m.clearednotBefore {
		edges = append(edges, delivery.EdgeNotBefore)
	}
	if m.clearednextReady {
		edges = append(edges, delivery.EdgeNextReady)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryMutation) EdgeCleared(name string) bool {
	switch name {
	case delivery.EdgeMessage:
		return m.clearedmessage
	case delivery.EdgeSubscription:
		return m.clearedsubscription
	case delivery.EdgeNotBefore:
		return m.clearednotBefore
	case delivery.EdgeNextReady:
		return m.clearednextReady
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryMutation) ClearEdge(name string) error {
	switch name {
	case delivery.EdgeMessage:
		m.ClearMessage()
		return nil
	case delivery.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case delivery.EdgeNotBefore:
		m.ClearNotBefore()
		return nil
	}
	return fmt.Errorf("unknown Delivery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryMutation) ResetEdge(name string) error {
	switch name {
	case delivery.EdgeMessage:
		m.ResetMessage()
		return nil
	case delivery.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case delivery.EdgeNotBefore:
		m.ResetNotBefore()
		return nil
	case delivery.EdgeNextReady:
		m.ResetNextReady()
		return nil
	}
	return fmt.Errorf("unknown Delivery edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	payload           *json.RawMessage
	appendpayload     json.RawMessage
	attributes        *map[string]string
	publishedAt       *time.Time
	orderKey          *string
	clearedFields     map[string]struct{}
	deliveries        map[uuid.UUID]struct{}
	removeddeliveries map[uuid.UUID]struct{}
	cleareddeliveries bool
	topic             *uuid.UUID
	clearedtopic      bool
	done              bool
	oldValue          func(context.Context) (*Message, error)
	predicates        []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTopicID sets the "topicID" field.
func (m *MessageMutation) SetTopicID(u uuid.UUID) {
	m.topic = &u
}

// TopicID returns the value of the "topicID" field in the mutation.
func (m *MessageMutation) TopicID() (r uuid.UUID, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicID returns the old "topicID" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldTopicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicID: %w", err)
	}
	return oldValue.TopicID, nil
}

// ResetTopicID resets all changes to the "topicID" field.
func (m *MessageMutation) ResetTopicID() {
	m.topic = nil
}

// SetPayload sets the "payload" field.
func (m *MessageMutation) SetPayload(jm json.RawMessage) {
	m.payload = &jm
	m.appendpayload = nil
}

// Payload returns the value of the "payload" field in the mutation.
func (m *MessageMutation) Payload() (r json.RawMessage, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPayload(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// AppendPayload adds jm to the "payload" field.
func (m *MessageMutation) AppendPayload(jm json.RawMessage) {
	m.appendpayload = append(m.appendpayload, jm...)
}

// AppendedPayload returns the list of values that were appended to the "payload" field in this mutation.
func (m *MessageMutation) AppendedPayload() (json.RawMessage, bool) {
	if len(m.appendpayload) == 0 {
		return nil, false
	}
	return m.appendpayload, true
}

// ResetPayload resets all changes to the "payload" field.
func (m *MessageMutation) ResetPayload() {
	m.payload = nil
	m.appendpayload = nil
}

// SetAttributes sets the "attributes" field.
func (m *MessageMutation) SetAttributes(value map[string]string) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *MessageMutation) Attributes() (r map[string]string, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAttributes(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *MessageMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[message.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *MessageMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[message.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *MessageMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, message.FieldAttributes)
}

// SetPublishedAt sets the "publishedAt" field.
func (m *MessageMutation) SetPublishedAt(t time.Time) {
	m.publishedAt = &t
}

// PublishedAt returns the value of the "publishedAt" field in the mutation.
func (m *MessageMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.publishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "publishedAt" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ResetPublishedAt resets all changes to the "publishedAt" field.
func (m *MessageMutation) ResetPublishedAt() {
	m.publishedAt = nil
}

// SetOrderKey sets the "orderKey" field.
func (m *MessageMutation) SetOrderKey(s string) {
	m.orderKey = &s
}

// OrderKey returns the value of the "orderKey" field in the mutation.
func (m *MessageMutation) OrderKey() (r string, exists bool) {
	v := m.orderKey
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderKey returns the old "orderKey" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldOrderKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderKey: %w", err)
	}
	return oldValue.OrderKey, nil
}

// ClearOrderKey clears the value of the "orderKey" field.
func (m *MessageMutation) ClearOrderKey() {
	m.orderKey = nil
	m.clearedFields[message.FieldOrderKey] = struct{}{}
}

// OrderKeyCleared returns if the "orderKey" field was cleared in this mutation.
func (m *MessageMutation) OrderKeyCleared() bool {
	_, ok := m.clearedFields[message.FieldOrderKey]
	return ok
}

// ResetOrderKey resets all changes to the "orderKey" field.
func (m *MessageMutation) ResetOrderKey() {
	m.orderKey = nil
	delete(m.clearedFields, message.FieldOrderKey)
}

// AddDeliveryIDs adds the "deliveries" edge to the Delivery entity by ids.
func (m *MessageMutation) AddDeliveryIDs(ids ...uuid.UUID) {
	if m.deliveries == nil {
		m.deliveries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.deliveries[ids[i]] = struct{}{}
	}
}

// ClearDeliveries clears the "deliveries" edge to the Delivery entity.
func (m *MessageMutation) ClearDeliveries() {
	m.cleareddeliveries = true
}

// DeliveriesCleared reports if the "deliveries" edge to the Delivery entity was cleared.
func (m *MessageMutation) DeliveriesCleared() bool {
	return m.cleareddeliveries
}

// RemoveDeliveryIDs removes the "deliveries" edge to the Delivery entity by IDs.
func (m *MessageMutation) RemoveDeliveryIDs(ids ...uuid.UUID) {
	if m.removeddeliveries == nil {
		m.removeddeliveries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.deliveries, ids[i])
		m.removeddeliveries[ids[i]] = struct{}{}
	}
}

// RemovedDeliveries returns the removed IDs of the "deliveries" edge to the Delivery entity.
func (m *MessageMutation) RemovedDeliveriesIDs() (ids []uuid.UUID) {
	for id := range m.removeddeliveries {
		ids = append(ids, id)
	}
	return
}

// DeliveriesIDs returns the "deliveries" edge IDs in the mutation.
func (m *MessageMutation) DeliveriesIDs() (ids []uuid.UUID) {
	for id := range m.deliveries {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveries resets all changes to the "deliveries" edge.
func (m *MessageMutation) ResetDeliveries() {
	m.deliveries = nil
	m.cleareddeliveries = false
	m.removeddeliveries = nil
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *MessageMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[message.FieldTopicID] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *MessageMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) TopicIDs() (ids []uuid.UUID) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *MessageMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.topic != nil {
		fields = append(fields, message.FieldTopicID)
	}
	if m.payload != nil {
		fields = append(fields, message.FieldPayload)
	}
	if m.attributes != nil {
		fields = append(fields, message.FieldAttributes)
	}
	if m.publishedAt != nil {
		fields = append(fields, message.FieldPublishedAt)
	}
	if m.orderKey != nil {
		fields = append(fields, message.FieldOrderKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldTopicID:
		return m.TopicID()
	case message.FieldPayload:
		return m.Payload()
	case message.FieldAttributes:
		return m.Attributes()
	case message.FieldPublishedAt:
		return m.PublishedAt()
	case message.FieldOrderKey:
		return m.OrderKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldTopicID:
		return m.OldTopicID(ctx)
	case message.FieldPayload:
		return m.OldPayload(ctx)
	case message.FieldAttributes:
		return m.OldAttributes(ctx)
	case message.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case message.FieldOrderKey:
		return m.OldOrderKey(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldTopicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	case message.FieldPayload:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case message.FieldAttributes:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case message.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case message.FieldOrderKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderKey(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldAttributes) {
		fields = append(fields, message.FieldAttributes)
	}
	if m.FieldCleared(message.FieldOrderKey) {
		fields = append(fields, message.FieldOrderKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldAttributes:
		m.ClearAttributes()
		return nil
	case message.FieldOrderKey:
		m.ClearOrderKey()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldTopicID:
		m.ResetTopicID()
		return nil
	case message.FieldPayload:
		m.ResetPayload()
		return nil
	case message.FieldAttributes:
		m.ResetAttributes()
		return nil
	case message.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case message.FieldOrderKey:
		m.ResetOrderKey()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deliveries != nil {
		edges = append(edges, message.EdgeDeliveries)
	}
	if m.topic != nil {
		edges = append(edges, message.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeDeliveries:
		ids := make([]ent.Value, 0, len(m.deliveries))
		for id := range m.deliveries {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeliveries != nil {
		edges = append(edges, message.EdgeDeliveries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeDeliveries:
		ids := make([]ent.Value, 0, len(m.removeddeliveries))
		for id := range m.removeddeliveries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeliveries {
		edges = append(edges, message.EdgeDeliveries)
	}
	if m.clearedtopic {
		edges = append(edges, message.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeDeliveries:
		return m.cleareddeliveries
	case message.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeDeliveries:
		m.ResetDeliveries()
		return nil
	case message.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// SnapshotMutation represents an operation that mutates the Snapshot nodes in the graph.
type SnapshotMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	name                  *string
	createdAt             *time.Time
	expiresAt             *time.Time
	labels                *map[string]string
	ackedMessagesBefore   *time.Time
	ackedMessageIDs       *[]uuid.UUID
	appendackedMessageIDs []uuid.UUID
	clearedFields         map[string]struct{}
	topic                 *uuid.UUID
	clearedtopic          bool
	done                  bool
	oldValue              func(context.Context) (*Snapshot, error)
	predicates            []predicate.Snapshot
}

var _ ent.Mutation = (*SnapshotMutation)(nil)

// snapshotOption allows management of the mutation configuration using functional options.
type snapshotOption func(*SnapshotMutation)

// newSnapshotMutation creates new mutation for the Snapshot entity.
func newSnapshotMutation(c config, op Op, opts ...snapshotOption) *SnapshotMutation {
	m := &SnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotID sets the ID field of the mutation.
func withSnapshotID(id uuid.UUID) snapshotOption {
	return func(m *SnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *Snapshot
		)
		m.oldValue = func(ctx context.Context) (*Snapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Snapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshot sets the old Snapshot of the mutation.
func withSnapshot(node *Snapshot) snapshotOption {
	return func(m *SnapshotMutation) {
		m.oldValue = func(context.Context) (*Snapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Snapshot entities.
func (m *SnapshotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Snapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTopicID sets the "topicID" field.
func (m *SnapshotMutation) SetTopicID(u uuid.UUID) {
	m.topic = &u
}

// TopicID returns the value of the "topicID" field in the mutation.
func (m *SnapshotMutation) TopicID() (r uuid.UUID, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicID returns the old "topicID" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldTopicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicID: %w", err)
	}
	return oldValue.TopicID, nil
}

// ResetTopicID resets all changes to the "topicID" field.
func (m *SnapshotMutation) ResetTopicID() {
	m.topic = nil
}

// SetName sets the "name" field.
func (m *SnapshotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SnapshotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SnapshotMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *SnapshotMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SnapshotMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetExpiresAt sets the "expiresAt" field.
func (m *SnapshotMutation) SetExpiresAt(t time.Time) {
	m.expiresAt = &t
}

// ExpiresAt returns the value of the "expiresAt" field in the mutation.
func (m *SnapshotMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expiresAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expiresAt" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expiresAt" field.
func (m *SnapshotMutation) ResetExpiresAt() {
	m.expiresAt = nil
}

// SetLabels sets the "labels" field.
func (m *SnapshotMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *SnapshotMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *SnapshotMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[snapshot.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *SnapshotMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[snapshot.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *SnapshotMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, snapshot.FieldLabels)
}

// SetAckedMessagesBefore sets the "ackedMessagesBefore" field.
func (m *SnapshotMutation) SetAckedMessagesBefore(t time.Time) {
	m.ackedMessagesBefore = &t
}

// AckedMessagesBefore returns the value of the "ackedMessagesBefore" field in the mutation.
func (m *SnapshotMutation) AckedMessagesBefore() (r time.Time, exists bool) {
	v := m.ackedMessagesBefore
	if v == nil {
		return
	}
	return *v, true
}

// OldAckedMessagesBefore returns the old "ackedMessagesBefore" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldAckedMessagesBefore(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAckedMessagesBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAckedMessagesBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAckedMessagesBefore: %w", err)
	}
	return oldValue.AckedMessagesBefore, nil
}

// ResetAckedMessagesBefore resets all changes to the "ackedMessagesBefore" field.
func (m *SnapshotMutation) ResetAckedMessagesBefore() {
	m.ackedMessagesBefore = nil
}

// SetAckedMessageIDs sets the "ackedMessageIDs" field.
func (m *SnapshotMutation) SetAckedMessageIDs(u []uuid.UUID) {
	m.ackedMessageIDs = &u
	m.appendackedMessageIDs = nil
}

// AckedMessageIDs returns the value of the "ackedMessageIDs" field in the mutation.
func (m *SnapshotMutation) AckedMessageIDs() (r []uuid.UUID, exists bool) {
	v := m.ackedMessageIDs
	if v == nil {
		return
	}
	return *v, true
}

// OldAckedMessageIDs returns the old "ackedMessageIDs" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldAckedMessageIDs(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAckedMessageIDs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAckedMessageIDs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAckedMessageIDs: %w", err)
	}
	return oldValue.AckedMessageIDs, nil
}

// AppendAckedMessageIDs adds u to the "ackedMessageIDs" field.
func (m *SnapshotMutation) AppendAckedMessageIDs(u []uuid.UUID) {
	m.appendackedMessageIDs = append(m.appendackedMessageIDs, u...)
}

// AppendedAckedMessageIDs returns the list of values that were appended to the "ackedMessageIDs" field in this mutation.
func (m *SnapshotMutation) AppendedAckedMessageIDs() ([]uuid.UUID, bool) {
	if len(m.appendackedMessageIDs) == 0 {
		return nil, false
	}
	return m.appendackedMessageIDs, true
}

// ClearAckedMessageIDs clears the value of the "ackedMessageIDs" field.
func (m *SnapshotMutation) ClearAckedMessageIDs() {
	m.ackedMessageIDs = nil
	m.appendackedMessageIDs = nil
	m.clearedFields[snapshot.FieldAckedMessageIDs] = struct{}{}
}

// AckedMessageIDsCleared returns if the "ackedMessageIDs" field was cleared in this mutation.
func (m *SnapshotMutation) AckedMessageIDsCleared() bool {
	_, ok := m.clearedFields[snapshot.FieldAckedMessageIDs]
	return ok
}

// ResetAckedMessageIDs resets all changes to the "ackedMessageIDs" field.
func (m *SnapshotMutation) ResetAckedMessageIDs() {
	m.ackedMessageIDs = nil
	m.appendackedMessageIDs = nil
	delete(m.clearedFields, snapshot.FieldAckedMessageIDs)
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *SnapshotMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[snapshot.FieldTopicID] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *SnapshotMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *SnapshotMutation) TopicIDs() (ids []uuid.UUID) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *SnapshotMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the SnapshotMutation builder.
func (m *SnapshotMutation) Where(ps ...predicate.Snapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Snapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Snapshot).
func (m *SnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.topic != nil {
		fields = append(fields, snapshot.FieldTopicID)
	}
	if m.name != nil {
		fields = append(fields, snapshot.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, snapshot.FieldCreatedAt)
	}
	if m.expiresAt != nil {
		fields = append(fields, snapshot.FieldExpiresAt)
	}
	if m.labels != nil {
		fields = append(fields, snapshot.FieldLabels)
	}
	if m.ackedMessagesBefore != nil {
		fields = append(fields, snapshot.FieldAckedMessagesBefore)
	}
	if m.ackedMessageIDs != nil {
		fields = append(fields, snapshot.FieldAckedMessageIDs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldTopicID:
		return m.TopicID()
	case snapshot.FieldName:
		return m.Name()
	case snapshot.FieldCreatedAt:
		return m.CreatedAt()
	case snapshot.FieldExpiresAt:
		return m.ExpiresAt()
	case snapshot.FieldLabels:
		return m.Labels()
	case snapshot.FieldAckedMessagesBefore:
		return m.AckedMessagesBefore()
	case snapshot.FieldAckedMessageIDs:
		return m.AckedMessageIDs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshot.FieldTopicID:
		return m.OldTopicID(ctx)
	case snapshot.FieldName:
		return m.OldName(ctx)
	case snapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case snapshot.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case snapshot.FieldLabels:
		return m.OldLabels(ctx)
	case snapshot.FieldAckedMessagesBefore:
		return m.OldAckedMessagesBefore(ctx)
	case snapshot.FieldAckedMessageIDs:
		return m.OldAckedMessageIDs(ctx)
	}
	return nil, fmt.Errorf("unknown Snapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldTopicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	case snapshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case snapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case snapshot.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case snapshot.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case snapshot.FieldAckedMessagesBefore:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAckedMessagesBefore(v)
		return nil
	case snapshot.FieldAckedMessageIDs:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAckedMessageIDs(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Snapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(snapshot.FieldLabels) {
		fields = append(fields, snapshot.FieldLabels)
	}
	if m.FieldCleared(snapshot.FieldAckedMessageIDs) {
		fields = append(fields, snapshot.FieldAckedMessageIDs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotMutation) ClearField(name string) error {
	switch name {
	case snapshot.FieldLabels:
		m.ClearLabels()
		return nil
	case snapshot.FieldAckedMessageIDs:
		m.ClearAckedMessageIDs()
		return nil
	}
	return fmt.Errorf("unknown Snapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotMutation) ResetField(name string) error {
	switch name {
	case snapshot.FieldTopicID:
		m.ResetTopicID()
		return nil
	case snapshot.FieldName:
		m.ResetName()
		return nil
	case snapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case snapshot.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case snapshot.FieldLabels:
		m.ResetLabels()
		return nil
	case snapshot.FieldAckedMessagesBefore:
		m.ResetAckedMessagesBefore()
		return nil
	case snapshot.FieldAckedMessageIDs:
		m.ResetAckedMessageIDs()
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.topic != nil {
		edges = append(edges, snapshot.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case snapshot.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtopic {
		edges = append(edges, snapshot.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case snapshot.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotMutation) ClearEdge(name string) error {
	switch name {
	case snapshot.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown Snapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotMutation) ResetEdge(name string) error {
	switch name {
	case snapshot.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown Snapshot edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	name                   *string
	createdAt              *time.Time
	expiresAt              *time.Time
	live                   *bool
	deletedAt              *time.Time
	ttl                    *sqltypes.Interval
	messageTTL             *sqltypes.Interval
	orderedDelivery        *bool
	labels                 *map[string]string
	minBackoff             **sqltypes.Interval
	maxBackoff             **sqltypes.Interval
	pushEndpoint           *string
	messageFilter          *string
	maxDeliveryAttempts    *int32
	addmaxDeliveryAttempts *int32
	deliveryDelay          *sqltypes.Interval
	clearedFields          map[string]struct{}
	topic                  *uuid.UUID
	clearedtopic           bool
	deliveries             map[uuid.UUID]struct{}
	removeddeliveries      map[uuid.UUID]struct{}
	cleareddeliveries      bool
	deadLetterTopic        *uuid.UUID
	cleareddeadLetterTopic bool
	done                   bool
	oldValue               func(context.Context) (*Subscription, error)
	predicates             []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id uuid.UUID) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTopicID sets the "topicID" field.
func (m *SubscriptionMutation) SetTopicID(u uuid.UUID) {
	m.topic = &u
}

// TopicID returns the value of the "topicID" field in the mutation.
func (m *SubscriptionMutation) TopicID() (r uuid.UUID, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicID returns the old "topicID" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTopicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicID: %w", err)
	}
	return oldValue.TopicID, nil
}

// ResetTopicID resets all changes to the "topicID" field.
func (m *SubscriptionMutation) ResetTopicID() {
	m.topic = nil
}

// SetName sets the "name" field.
func (m *SubscriptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetExpiresAt sets the "expiresAt" field.
func (m *SubscriptionMutation) SetExpiresAt(t time.Time) {
	m.expiresAt = &t
}

// ExpiresAt returns the value of the "expiresAt" field in the mutation.
func (m *SubscriptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expiresAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expiresAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expiresAt" field.
func (m *SubscriptionMutation) ResetExpiresAt() {
	m.expiresAt = nil
}

// SetLive sets the "live" field.
func (m *SubscriptionMutation) SetLive(b bool) {
	m.live = &b
}

// Live returns the value of the "live" field in the mutation.
func (m *SubscriptionMutation) Live() (r bool, exists bool) {
	v := m.live
	if v == nil {
		return
	}
	return *v, true
}

// OldLive returns the old "live" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldLive(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLive: %w", err)
	}
	return oldValue.Live, nil
}

// ClearLive clears the value of the "live" field.
func (m *SubscriptionMutation) ClearLive() {
	m.live = nil
	m.clearedFields[subscription.FieldLive] = struct{}{}
}

// LiveCleared returns if the "live" field was cleared in this mutation.
func (m *SubscriptionMutation) LiveCleared() bool {
	_, ok := m.clearedFields[subscription.FieldLive]
	return ok
}

// ResetLive resets all changes to the "live" field.
func (m *SubscriptionMutation) ResetLive() {
	m.live = nil
	delete(m.clearedFields, subscription.FieldLive)
}

// SetDeletedAt sets the "deletedAt" field.
func (m *SubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *SubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *SubscriptionMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[subscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *SubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *SubscriptionMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, subscription.FieldDeletedAt)
}

// SetTTL sets the "ttl" field.
func (m *SubscriptionMutation) SetTTL(s sqltypes.Interval) {
	m.ttl = &s
}

// TTL returns the value of the "ttl" field in the mutation.
func (m *SubscriptionMutation) TTL() (r sqltypes.Interval, exists bool) {
	v := m.ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldTTL returns the old "ttl" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTTL(ctx context.Context) (v sqltypes.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTL: %w", err)
	}
	return oldValue.TTL, nil
}

// ResetTTL resets all changes to the "ttl" field.
func (m *SubscriptionMutation) ResetTTL() {
	m.ttl = nil
}

// SetMessageTTL sets the "messageTTL" field.
func (m *SubscriptionMutation) SetMessageTTL(s sqltypes.Interval) {
	m.messageTTL = &s
}

// MessageTTL returns the value of the "messageTTL" field in the mutation.
func (m *SubscriptionMutation) MessageTTL() (r sqltypes.Interval, exists bool) {
	v := m.messageTTL
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageTTL returns the old "messageTTL" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMessageTTL(ctx context.Context) (v sqltypes.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageTTL: %w", err)
	}
	return oldValue.MessageTTL, nil
}

// ResetMessageTTL resets all changes to the "messageTTL" field.
func (m *SubscriptionMutation) ResetMessageTTL() {
	m.messageTTL = nil
}

// SetOrderedDelivery sets the "orderedDelivery" field.
func (m *SubscriptionMutation) SetOrderedDelivery(b bool) {
	m.orderedDelivery = &b
}

// OrderedDelivery returns the value of the "orderedDelivery" field in the mutation.
func (m *SubscriptionMutation) OrderedDelivery() (r bool, exists bool) {
	v := m.orderedDelivery
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderedDelivery returns the old "orderedDelivery" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldOrderedDelivery(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderedDelivery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderedDelivery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderedDelivery: %w", err)
	}
	return oldValue.OrderedDelivery, nil
}

// ClearOrderedDelivery clears the value of the "orderedDelivery" field.
func (m *SubscriptionMutation) ClearOrderedDelivery() {
	m.orderedDelivery = nil
	m.clearedFields[subscription.FieldOrderedDelivery] = struct{}{}
}

// OrderedDeliveryCleared returns if the "orderedDelivery" field was cleared in this mutation.
func (m *SubscriptionMutation) OrderedDeliveryCleared() bool {
	_, ok := m.clearedFields[subscription.FieldOrderedDelivery]
	return ok
}

// ResetOrderedDelivery resets all changes to the "orderedDelivery" field.
func (m *SubscriptionMutation) ResetOrderedDelivery() {
	m.orderedDelivery = nil
	delete(m.clearedFields, subscription.FieldOrderedDelivery)
}

// SetLabels sets the "labels" field.
func (m *SubscriptionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *SubscriptionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *SubscriptionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[subscription.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *SubscriptionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[subscription.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *SubscriptionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, subscription.FieldLabels)
}

// SetMinBackoff sets the "minBackoff" field.
func (m *SubscriptionMutation) SetMinBackoff(s *sqltypes.Interval) {
	m.minBackoff = &s
}

// MinBackoff returns the value of the "minBackoff" field in the mutation.
func (m *SubscriptionMutation) MinBackoff() (r *sqltypes.Interval, exists bool) {
	v := m.minBackoff
	if v == nil {
		return
	}
	return *v, true
}

// OldMinBackoff returns the old "minBackoff" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMinBackoff(ctx context.Context) (v *sqltypes.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinBackoff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinBackoff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinBackoff: %w", err)
	}
	return oldValue.MinBackoff, nil
}

// ClearMinBackoff clears the value of the "minBackoff" field.
func (m *SubscriptionMutation) ClearMinBackoff() {
	m.minBackoff = nil
	m.clearedFields[subscription.FieldMinBackoff] = struct{}{}
}

// MinBackoffCleared returns if the "minBackoff" field was cleared in this mutation.
func (m *SubscriptionMutation) MinBackoffCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMinBackoff]
	return ok
}

// ResetMinBackoff resets all changes to the "minBackoff" field.
func (m *SubscriptionMutation) ResetMinBackoff() {
	m.minBackoff = nil
	delete(m.clearedFields, subscription.FieldMinBackoff)
}

// SetMaxBackoff sets the "maxBackoff" field.
func (m *SubscriptionMutation) SetMaxBackoff(s *sqltypes.Interval) {
	m.maxBackoff = &s
}

// MaxBackoff returns the value of the "maxBackoff" field in the mutation.
func (m *SubscriptionMutation) MaxBackoff() (r *sqltypes.Interval, exists bool) {
	v := m.maxBackoff
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxBackoff returns the old "maxBackoff" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMaxBackoff(ctx context.Context) (v *sqltypes.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxBackoff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxBackoff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxBackoff: %w", err)
	}
	return oldValue.MaxBackoff, nil
}

// ClearMaxBackoff clears the value of the "maxBackoff" field.
func (m *SubscriptionMutation) ClearMaxBackoff() {
	m.maxBackoff = nil
	m.clearedFields[subscription.FieldMaxBackoff] = struct{}{}
}

// MaxBackoffCleared returns if the "maxBackoff" field was cleared in this mutation.
func (m *SubscriptionMutation) MaxBackoffCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMaxBackoff]
	return ok
}

// ResetMaxBackoff resets all changes to the "maxBackoff" field.
func (m *SubscriptionMutation) ResetMaxBackoff() {
	m.maxBackoff = nil
	delete(m.clearedFields, subscription.FieldMaxBackoff)
}

// SetPushEndpoint sets the "pushEndpoint" field.
func (m *SubscriptionMutation) SetPushEndpoint(s string) {
	m.pushEndpoint = &s
}

// PushEndpoint returns the value of the "pushEndpoint" field in the mutation.
func (m *SubscriptionMutation) PushEndpoint() (r string, exists bool) {
	v := m.pushEndpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldPushEndpoint returns the old "pushEndpoint" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPushEndpoint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushEndpoint: %w", err)
	}
	return oldValue.PushEndpoint, nil
}

// ClearPushEndpoint clears the value of the "pushEndpoint" field.
func (m *SubscriptionMutation) ClearPushEndpoint() {
	m.pushEndpoint = nil
	m.clearedFields[subscription.FieldPushEndpoint] = struct{}{}
}

// PushEndpointCleared returns if the "pushEndpoint" field was cleared in this mutation.
func (m *SubscriptionMutation) PushEndpointCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPushEndpoint]
	return ok
}

// ResetPushEndpoint resets all changes to the "pushEndpoint" field.
func (m *SubscriptionMutation) ResetPushEndpoint() {
	m.pushEndpoint = nil
	delete(m.clearedFields, subscription.FieldPushEndpoint)
}

// SetMessageFilter sets the "messageFilter" field.
func (m *SubscriptionMutation) SetMessageFilter(s string) {
	m.messageFilter = &s
}

// MessageFilter returns the value of the "messageFilter" field in the mutation.
func (m *SubscriptionMutation) MessageFilter() (r string, exists bool) {
	v := m.messageFilter
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageFilter returns the old "messageFilter" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMessageFilter(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageFilter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageFilter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageFilter: %w", err)
	}
	return oldValue.MessageFilter, nil
}

// ClearMessageFilter clears the value of the "messageFilter" field.
func (m *SubscriptionMutation) ClearMessageFilter() {
	m.messageFilter = nil
	m.clearedFields[subscription.FieldMessageFilter] = struct{}{}
}

// MessageFilterCleared returns if the "messageFilter" field was cleared in this mutation.
func (m *SubscriptionMutation) MessageFilterCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMessageFilter]
	return ok
}

// ResetMessageFilter resets all changes to the "messageFilter" field.
func (m *SubscriptionMutation) ResetMessageFilter() {
	m.messageFilter = nil
	delete(m.clearedFields, subscription.FieldMessageFilter)
}

// SetMaxDeliveryAttempts sets the "maxDeliveryAttempts" field.
func (m *SubscriptionMutation) SetMaxDeliveryAttempts(i int32) {
	m.maxDeliveryAttempts = &i
	m.addmaxDeliveryAttempts = nil
}

// MaxDeliveryAttempts returns the value of the "maxDeliveryAttempts" field in the mutation.
func (m *SubscriptionMutation) MaxDeliveryAttempts() (r int32, exists bool) {
	v := m.maxDeliveryAttempts
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDeliveryAttempts returns the old "maxDeliveryAttempts" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMaxDeliveryAttempts(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDeliveryAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDeliveryAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDeliveryAttempts: %w", err)
	}
	return oldValue.MaxDeliveryAttempts, nil
}

// AddMaxDeliveryAttempts adds i to the "maxDeliveryAttempts" field.
func (m *SubscriptionMutation) AddMaxDeliveryAttempts(i int32) {
	if m.addmaxDeliveryAttempts != nil {
		*m.addmaxDeliveryAttempts += i
	} else {
		m.addmaxDeliveryAttempts = &i
	}
}

// AddedMaxDeliveryAttempts returns the value that was added to the "maxDeliveryAttempts" field in this mutation.
func (m *SubscriptionMutation) AddedMaxDeliveryAttempts() (r int32, exists bool) {
	v := m.addmaxDeliveryAttempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxDeliveryAttempts clears the value of the "maxDeliveryAttempts" field.
func (m *SubscriptionMutation) ClearMaxDeliveryAttempts() {
	m.maxDeliveryAttempts = nil
	m.addmaxDeliveryAttempts = nil
	m.clearedFields[subscription.FieldMaxDeliveryAttempts] = struct{}{}
}

// MaxDeliveryAttemptsCleared returns if the "maxDeliveryAttempts" field was cleared in this mutation.
func (m *SubscriptionMutation) MaxDeliveryAttemptsCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMaxDeliveryAttempts]
	return ok
}

// ResetMaxDeliveryAttempts resets all changes to the "maxDeliveryAttempts" field.
func (m *SubscriptionMutation) ResetMaxDeliveryAttempts() {
	m.maxDeliveryAttempts = nil
	m.addmaxDeliveryAttempts = nil
	delete(m.clearedFields, subscription.FieldMaxDeliveryAttempts)
}

// SetDeadLetterTopicID sets the "deadLetterTopicID" field.
func (m *SubscriptionMutation) SetDeadLetterTopicID(u uuid.UUID) {
	m.deadLetterTopic = &u
}

// DeadLetterTopicID returns the value of the "deadLetterTopicID" field in the mutation.
func (m *SubscriptionMutation) DeadLetterTopicID() (r uuid.UUID, exists bool) {
	v := m.deadLetterTopic
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadLetterTopicID returns the old "deadLetterTopicID" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeadLetterTopicID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadLetterTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadLetterTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadLetterTopicID: %w", err)
	}
	return oldValue.DeadLetterTopicID, nil
}

// ClearDeadLetterTopicID clears the value of the "deadLetterTopicID" field.
func (m *SubscriptionMutation) ClearDeadLetterTopicID() {
	m.deadLetterTopic = nil
	m.clearedFields[subscription.FieldDeadLetterTopicID] = struct{}{}
}

// DeadLetterTopicIDCleared returns if the "deadLetterTopicID" field was cleared in this mutation.
func (m *SubscriptionMutation) DeadLetterTopicIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDeadLetterTopicID]
	return ok
}

// ResetDeadLetterTopicID resets all changes to the "deadLetterTopicID" field.
func (m *SubscriptionMutation) ResetDeadLetterTopicID() {
	m.deadLetterTopic = nil
	delete(m.clearedFields, subscription.FieldDeadLetterTopicID)
}

// SetDeliveryDelay sets the "deliveryDelay" field.
func (m *SubscriptionMutation) SetDeliveryDelay(s sqltypes.Interval) {
	m.deliveryDelay = &s
}

// DeliveryDelay returns the value of the "deliveryDelay" field in the mutation.
func (m *SubscriptionMutation) DeliveryDelay() (r sqltypes.Interval, exists bool) {
	v := m.deliveryDelay
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryDelay returns the old "deliveryDelay" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeliveryDelay(ctx context.Context) (v sqltypes.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryDelay: %w", err)
	}
	return oldValue.DeliveryDelay, nil
}

// ResetDeliveryDelay resets all changes to the "deliveryDelay" field.
func (m *SubscriptionMutation) ResetDeliveryDelay() {
	m.deliveryDelay = nil
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *SubscriptionMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[subscription.FieldTopicID] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *SubscriptionMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) TopicIDs() (ids []uuid.UUID) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *SubscriptionMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// AddDeliveryIDs adds the "deliveries" edge to the Delivery entity by ids.
func (m *SubscriptionMutation) AddDeliveryIDs(ids ...uuid.UUID) {
	if m.deliveries == nil {
		m.deliveries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.deliveries[ids[i]] = struct{}{}
	}
}

// ClearDeliveries clears the "deliveries" edge to the Delivery entity.
func (m *SubscriptionMutation) ClearDeliveries() {
	m.cleareddeliveries = true
}

// DeliveriesCleared reports if the "deliveries" edge to the Delivery entity was cleared.
func (m *SubscriptionMutation) DeliveriesCleared() bool {
	return m.cleareddeliveries
}

// RemoveDeliveryIDs removes the "deliveries" edge to the Delivery entity by IDs.
func (m *SubscriptionMutation) RemoveDeliveryIDs(ids ...uuid.UUID) {
	if m.removeddeliveries == nil {
		m.removeddeliveries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.deliveries, ids[i])
		m.removeddeliveries[ids[i]] = struct{}{}
	}
}

// RemovedDeliveries returns the removed IDs of the "deliveries" edge to the Delivery entity.
func (m *SubscriptionMutation) RemovedDeliveriesIDs() (ids []uuid.UUID) {
	for id := range m.removeddeliveries {
		ids = append(ids, id)
	}
	return
}

// DeliveriesIDs returns the "deliveries" edge IDs in the mutation.
func (m *SubscriptionMutation) DeliveriesIDs() (ids []uuid.UUID) {
	for id := range m.deliveries {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveries resets all changes to the "deliveries" edge.
func (m *SubscriptionMutation) ResetDeliveries() {
	m.deliveries = nil
	m.cleareddeliveries = false
	m.removeddeliveries = nil
}

// ClearDeadLetterTopic clears the "deadLetterTopic" edge to the Topic entity.
func (m *SubscriptionMutation) ClearDeadLetterTopic() {
	m.cleareddeadLetterTopic = true
	m.clearedFields[subscription.FieldDeadLetterTopicID] = struct{}{}
}

// DeadLetterTopicCleared reports if the "deadLetterTopic" edge to the Topic entity was cleared.
func (m *SubscriptionMutation) DeadLetterTopicCleared() bool {
	return m.DeadLetterTopicIDCleared() || m.cleareddeadLetterTopic
}

// DeadLetterTopicIDs returns the "deadLetterTopic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeadLetterTopicID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) DeadLetterTopicIDs() (ids []uuid.UUID) {
	if id := m.deadLetterTopic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeadLetterTopic resets all changes to the "deadLetterTopic" edge.
func (m *SubscriptionMutation) ResetDeadLetterTopic() {
	m.deadLetterTopic = nil
	m.cleareddeadLetterTopic = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.topic != nil {
		fields = append(fields, subscription.FieldTopicID)
	}
	if m.name != nil {
		fields = append(fields, subscription.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.expiresAt != nil {
		fields = append(fields, subscription.FieldExpiresAt)
	}
	if m.live != nil {
		fields = append(fields, subscription.FieldLive)
	}
	if m.deletedAt != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.ttl != nil {
		fields = append(fields, subscription.FieldTTL)
	}
	if m.messageTTL != nil {
		fields = append(fields, subscription.FieldMessageTTL)
	}
	if m.orderedDelivery != nil {
		fields = append(fields, subscription.FieldOrderedDelivery)
	}
	if m.labels != nil {
		fields = append(fields, subscription.FieldLabels)
	}
	if m.minBackoff != nil {
		fields = append(fields, subscription.FieldMinBackoff)
	}
	if m.maxBackoff != nil {
		fields = append(fields, subscription.FieldMaxBackoff)
	}
	if m.pushEndpoint != nil {
		fields = append(fields, subscription.FieldPushEndpoint)
	}
	if m.messageFilter != nil {
		fields = append(fields, subscription.FieldMessageFilter)
	}
	if m.maxDeliveryAttempts != nil {
		fields = append(fields, subscription.FieldMaxDeliveryAttempts)
	}
	if m.deadLetterTopic != nil {
		fields = append(fields, subscription.FieldDeadLetterTopicID)
	}
	if m.deliveryDelay != nil {
		fields = append(fields, subscription.FieldDeliveryDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldTopicID:
		return m.TopicID()
	case subscription.FieldName:
		return m.Name()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldExpiresAt:
		return m.ExpiresAt()
	case subscription.FieldLive:
		return m.Live()
	case subscription.FieldDeletedAt:
		return m.DeletedAt()
	case subscription.FieldTTL:
		return m.TTL()
	case subscription.FieldMessageTTL:
		return m.MessageTTL()
	case subscription.FieldOrderedDelivery:
		return m.OrderedDelivery()
	case subscription.FieldLabels:
		return m.Labels()
	case subscription.FieldMinBackoff:
		return m.MinBackoff()
	case subscription.FieldMaxBackoff:
		return m.MaxBackoff()
	case subscription.FieldPushEndpoint:
		return m.PushEndpoint()
	case subscription.FieldMessageFilter:
		return m.MessageFilter()
	case subscription.FieldMaxDeliveryAttempts:
		return m.MaxDeliveryAttempts()
	case subscription.FieldDeadLetterTopicID:
		return m.DeadLetterTopicID()
	case subscription.FieldDeliveryDelay:
		return m.DeliveryDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldTopicID:
		return m.OldTopicID(ctx)
	case subscription.FieldName:
		return m.OldName(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case subscription.FieldLive:
		return m.OldLive(ctx)
	case subscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscription.FieldTTL:
		return m.OldTTL(ctx)
	case subscription.FieldMessageTTL:
		return m.OldMessageTTL(ctx)
	case subscription.FieldOrderedDelivery:
		return m.OldOrderedDelivery(ctx)
	case subscription.FieldLabels:
		return m.OldLabels(ctx)
	case subscription.FieldMinBackoff:
		return m.OldMinBackoff(ctx)
	case subscription.FieldMaxBackoff:
		return m.OldMaxBackoff(ctx)
	case subscription.FieldPushEndpoint:
		return m.OldPushEndpoint(ctx)
	case subscription.FieldMessageFilter:
		return m.OldMessageFilter(ctx)
	case subscription.FieldMaxDeliveryAttempts:
		return m.OldMaxDeliveryAttempts(ctx)
	case subscription.FieldDeadLetterTopicID:
		return m.OldDeadLetterTopicID(ctx)
	case subscription.FieldDeliveryDelay:
		return m.OldDeliveryDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldTopicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	case subscription.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case subscription.FieldLive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLive(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscription.FieldTTL:
		v, ok := value.(sqltypes.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTL(v)
		return nil
	case subscription.FieldMessageTTL:
		v, ok := value.(sqltypes.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageTTL(v)
		return nil
	case subscription.FieldOrderedDelivery:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderedDelivery(v)
		return nil
	case subscription.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case subscription.FieldMinBackoff:
		v, ok := value.(*sqltypes.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinBackoff(v)
		return nil
	case subscription.FieldMaxBackoff:
		v, ok := value.(*sqltypes.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxBackoff(v)
		return nil
	case subscription.FieldPushEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushEndpoint(v)
		return nil
	case subscription.FieldMessageFilter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageFilter(v)
		return nil
	case subscription.FieldMaxDeliveryAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDeliveryAttempts(v)
		return nil
	case subscription.FieldDeadLetterTopicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadLetterTopicID(v)
		return nil
	case subscription.FieldDeliveryDelay:
		v, ok := value.(sqltypes.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addmaxDeliveryAttempts != nil {
		fields = append(fields, subscription.FieldMaxDeliveryAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldMaxDeliveryAttempts:
		return m.AddedMaxDeliveryAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldMaxDeliveryAttempts:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDeliveryAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldLive) {
		fields = append(fields, subscription.FieldLive)
	}
	if m.FieldCleared(subscription.FieldDeletedAt) {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.FieldCleared(subscription.FieldOrderedDelivery) {
		fields = append(fields, subscription.FieldOrderedDelivery)
	}
	if m.FieldCleared(subscription.FieldLabels) {
		fields = append(fields, subscription.FieldLabels)
	}
	if m.FieldCleared(subscription.FieldMinBackoff) {
		fields = append(fields, subscription.FieldMinBackoff)
	}
	if m.FieldCleared(subscription.FieldMaxBackoff) {
		fields = append(fields, subscription.FieldMaxBackoff)
	}
	if m.FieldCleared(subscription.FieldPushEndpoint) {
		fields = append(fields, subscription.FieldPushEndpoint)
	}
	if m.FieldCleared(subscription.FieldMessageFilter) {
		fields = append(fields, subscription.FieldMessageFilter)
	}
	if m.FieldCleared(subscription.FieldMaxDeliveryAttempts) {
		fields = append(fields, subscription.FieldMaxDeliveryAttempts)
	}
	if m.FieldCleared(subscription.FieldDeadLetterTopicID) {
		fields = append(fields, subscription.FieldDeadLetterTopicID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldLive:
		m.ClearLive()
		return nil
	case subscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscription.FieldOrderedDelivery:
		m.ClearOrderedDelivery()
		return nil
	case subscription.FieldLabels:
		m.ClearLabels()
		return nil
	case subscription.FieldMinBackoff:
		m.ClearMinBackoff()
		return nil
	case subscription.FieldMaxBackoff:
		m.ClearMaxBackoff()
		return nil
	case subscription.FieldPushEndpoint:
		m.ClearPushEndpoint()
		return nil
	case subscription.FieldMessageFilter:
		m.ClearMessageFilter()
		return nil
	case subscription.FieldMaxDeliveryAttempts:
		m.ClearMaxDeliveryAttempts()
		return nil
	case subscription.FieldDeadLetterTopicID:
		m.ClearDeadLetterTopicID()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldTopicID:
		m.ResetTopicID()
		return nil
	case subscription.FieldName:
		m.ResetName()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case subscription.FieldLive:
		m.ResetLive()
		return nil
	case subscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscription.FieldTTL:
		m.ResetTTL()
		return nil
	case subscription.FieldMessageTTL:
		m.ResetMessageTTL()
		return nil
	case subscription.FieldOrderedDelivery:
		m.ResetOrderedDelivery()
		return nil
	case subscription.FieldLabels:
		m.ResetLabels()
		return nil
	case subscription.FieldMinBackoff:
		m.ResetMinBackoff()
		return nil
	case subscription.FieldMaxBackoff:
		m.ResetMaxBackoff()
		return nil
	case subscription.FieldPushEndpoint:
		m.ResetPushEndpoint()
		return nil
	case subscription.FieldMessageFilter:
		m.ResetMessageFilter()
		return nil
	case subscription.FieldMaxDeliveryAttempts:
		m.ResetMaxDeliveryAttempts()
		return nil
	case subscription.FieldDeadLetterTopicID:
		m.ResetDeadLetterTopicID()
		return nil
	case subscription.FieldDeliveryDelay:
		m.ResetDeliveryDelay()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.topic != nil {
		edges = append(edges, subscription.EdgeTopic)
	}
	if m.deliveries != nil {
		edges = append(edges, subscription.EdgeDeliveries)
	}
	if m.deadLetterTopic != nil {
		edges = append(edges, subscription.EdgeDeadLetterTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeDeliveries:
		ids := make([]ent.Value, 0, len(m.deliveries))
		for id := range m.deliveries {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeDeadLetterTopic:
		if id := m.deadLetterTopic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddeliveries != nil {
		edges = append(edges, subscription.EdgeDeliveries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeDeliveries:
		ids := make([]ent.Value, 0, len(m.removeddeliveries))
		for id := range m.removeddeliveries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtopic {
		edges = append(edges, subscription.EdgeTopic)
	}
	if m.cleareddeliveries {
		edges = append(edges, subscription.EdgeDeliveries)
	}
	if m.cleareddeadLetterTopic {
		edges = append(edges, subscription.EdgeDeadLetterTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeTopic:
		return m.clearedtopic
	case subscription.EdgeDeliveries:
		return m.cleareddeliveries
	case subscription.EdgeDeadLetterTopic:
		return m.cleareddeadLetterTopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeTopic:
		m.ClearTopic()
		return nil
	case subscription.EdgeDeadLetterTopic:
		m.ClearDeadLetterTopic()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeTopic:
		m.ResetTopic()
		return nil
	case subscription.EdgeDeliveries:
		m.ResetDeliveries()
		return nil
	case subscription.EdgeDeadLetterTopic:
		m.ResetDeadLetterTopic()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// TopicMutation represents an operation that mutates the Topic nodes in the graph.
type TopicMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	createdAt            *time.Time
	live                 *bool
	deletedAt            *time.Time
	labels               *map[string]string
	clearedFields        map[string]struct{}
	subscriptions        map[uuid.UUID]struct{}
	removedsubscriptions map[uuid.UUID]struct{}
	clearedsubscriptions bool
	messages             map[uuid.UUID]struct{}
	removedmessages      map[uuid.UUID]struct{}
	clearedmessages      bool
	done                 bool
	oldValue             func(context.Context) (*Topic, error)
	predicates           []predicate.Topic
}

var _ ent.Mutation = (*TopicMutation)(nil)

// topicOption allows management of the mutation configuration using functional options.
type topicOption func(*TopicMutation)

// newTopicMutation creates new mutation for the Topic entity.
func newTopicMutation(c config, op Op, opts ...topicOption) *TopicMutation {
	m := &TopicMutation{
		config:        c,
		op:            op,
		typ:           TypeTopic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicID sets the ID field of the mutation.
func withTopicID(id uuid.UUID) topicOption {
	return func(m *TopicMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic
		)
		m.oldValue = func(ctx context.Context) (*Topic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic sets the old Topic of the mutation.
func withTopic(node *Topic) topicOption {
	return func(m *TopicMutation) {
		m.oldValue = func(context.Context) (*Topic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Topic entities.
func (m *TopicMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TopicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TopicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TopicMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TopicMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TopicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TopicMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetLive sets the "live" field.
func (m *TopicMutation) SetLive(b bool) {
	m.live = &b
}

// Live returns the value of the "live" field in the mutation.
func (m *TopicMutation) Live() (r bool, exists bool) {
	v := m.live
	if v == nil {
		return
	}
	return *v, true
}

// OldLive returns the old "live" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldLive(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLive: %w", err)
	}
	return oldValue.Live, nil
}

// ClearLive clears the value of the "live" field.
func (m *TopicMutation) ClearLive() {
	m.live = nil
	m.clearedFields[topic.FieldLive] = struct{}{}
}

// LiveCleared returns if the "live" field was cleared in this mutation.
func (m *TopicMutation) LiveCleared() bool {
	_, ok := m.clearedFields[topic.FieldLive]
	return ok
}

// ResetLive resets all changes to the "live" field.
func (m *TopicMutation) ResetLive() {
	m.live = nil
	delete(m.clearedFields, topic.FieldLive)
}

// SetDeletedAt sets the "deletedAt" field.
func (m *TopicMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *TopicMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *TopicMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[topic.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *TopicMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[topic.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *TopicMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, topic.FieldDeletedAt)
}

// SetLabels sets the "labels" field.
func (m *TopicMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *TopicMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *TopicMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[topic.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *TopicMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[topic.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *TopicMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, topic.FieldLabels)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *TopicMutation) AddSubscriptionIDs(ids ...uuid.UUID) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *TopicMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *TopicMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *TopicMutation) RemoveSubscriptionIDs(ids ...uuid.UUID) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *TopicMutation) RemovedSubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *TopicMutation) SubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *TopicMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *TopicMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *TopicMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *TopicMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *TopicMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *TopicMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *TopicMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *TopicMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the TopicMutation builder.
func (m *TopicMutation) Where(ps ...predicate.Topic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Topic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Topic).
func (m *TopicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, topic.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, topic.FieldCreatedAt)
	}
	if m.live != nil {
		fields = append(fields, topic.FieldLive)
	}
	if m.deletedAt != nil {
		fields = append(fields, topic.FieldDeletedAt)
	}
	if m.labels != nil {
		fields = append(fields, topic.FieldLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic.FieldName:
		return m.Name()
	case topic.FieldCreatedAt:
		return m.CreatedAt()
	case topic.FieldLive:
		return m.Live()
	case topic.FieldDeletedAt:
		return m.DeletedAt()
	case topic.FieldLabels:
		return m.Labels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic.FieldName:
		return m.OldName(ctx)
	case topic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topic.FieldLive:
		return m.OldLive(ctx)
	case topic.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topic.FieldLabels:
		return m.OldLabels(ctx)
	}
	return nil, fmt.Errorf("unknown Topic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case topic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topic.FieldLive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLive(v)
		return nil
	case topic.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topic.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topic.FieldLive) {
		fields = append(fields, topic.FieldLive)
	}
	if m.FieldCleared(topic.FieldDeletedAt) {
		fields = append(fields, topic.FieldDeletedAt)
	}
	if m.FieldCleared(topic.FieldLabels) {
		fields = append(fields, topic.FieldLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicMutation) ClearField(name string) error {
	switch name {
	case topic.FieldLive:
		m.ClearLive()
		return nil
	case topic.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case topic.FieldLabels:
		m.ClearLabels()
		return nil
	}
	return fmt.Errorf("unknown Topic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicMutation) ResetField(name string) error {
	switch name {
	case topic.FieldName:
		m.ResetName()
		return nil
	case topic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topic.FieldLive:
		m.ResetLive()
		return nil
	case topic.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topic.FieldLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subscriptions != nil {
		edges = append(edges, topic.EdgeSubscriptions)
	}
	if m.messages != nil {
		edges = append(edges, topic.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubscriptions != nil {
		edges = append(edges, topic.EdgeSubscriptions)
	}
	if m.removedmessages != nil {
		edges = append(edges, topic.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubscriptions {
		edges = append(edges, topic.EdgeSubscriptions)
	}
	if m.clearedmessages {
		edges = append(edges, topic.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicMutation) EdgeCleared(name string) bool {
	switch name {
	case topic.EdgeSubscriptions:
		return m.clearedsubscriptions
	case topic.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicMutation) ResetEdge(name string) error {
	switch name {
	case topic.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case topic.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Topic edge %s", name)
}
